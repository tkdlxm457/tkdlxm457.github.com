---
title: codeup기초-종합
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true
categories: codeup
---

# 1096 : [기초-2차원배열] 바둑판에 흰 돌 놓기

문제설명

기숙사 생활을 하는 학교에서 어떤 금요일(전원 귀가일)에는 모두 집으로 귀가를 한다.

오랜만에 집에 간 영일이는 아버지와 함께 두던 매우 큰 오목에 대해서 생각해 보다가
"바둑판에 돌을 올린 것을 프로그래밍 할 수 있을까?"하고 생각하였다.

바둑판(19 * 19)에 n개의 흰 돌을 놓는다고 할 때,
n개의 흰 돌이 놓인 위치를 출력하는 프로그램을 작성해보자.


참고
가로번호, 세로번호를 사용할 수 있는 2차원 배열을 사용하면
이러한 형태를 쉽게 기록하고 사용할 수 있다. 물론 더 확장한 n차원 배열도 만들 수 있다.

정답

```
#include <stdio.h>

int n, i, j, a, b;
int map[20][20];

main()
{
	scanf("%d", &n);
	for(i=0; i < n; i++)
	{
		scanf("%d%d", &a, &b);
		map[a][b] = 1;
	}
	
	for(i=1; i <= 19; i++)
	{
		for(j=1; j <= 19; j++)
		{
			printf("%d ", map[i][j]);
		}
		printf("\n");
	}
}
```

# 1097 : [기초-2차원배열] 바둑알 십자 뒤집기

문제설명

부모님을 기다리던 영일이는 검정/흰 색 바둑알을 바둑판에 꽉 채워 깔아 놓고 놀다가...

"십(+)자 뒤집기를 해볼까?"하고 생각했다.

바둑판(19 * 19)에 흰 돌(1) 또는 검정 돌(0)이 모두 꽉 채워져 놓여있을 때,
n개의 좌표를 입력받아 십(+)자 뒤집기한 결과를 출력하는 프로그램을 작성해보자.

참고
가로 번호, 세로 번호를 사용할 수 있는 2차원 배열을 사용하면
이러한 형태를 쉽게 기록하고 사용할 수 있다. 물론 더 확장한 n차원 배열도 만들 수 있다.

정답

```
#include <stdio.h>

int n, i, j, k, a, b;
int map[20][20];

int main()
{
	for(i=1; i <= 19; i++)
		for(j=1; j <= 19; j++)
			scanf("%d", &map[i][j]);
	
	scanf("%d", &n);
	for(i=0; i < n; i++)
	{
		scanf("%d%d", &a, &b);
		for(j=1; j <= 19; j++)
			if(map[a][j] == 1) map[a][j]=0;
			else map[a][j]=1;
		for(j=1; j <= 19; j++)
			if(map[j][b] == 1) map[j][b]=0;
			else map[j][b]=1;
	}
	
	for(i=1; i <= 19; i++, puts(""))
		for(j=1; j <= 19; j++)
		{
			printf("%d ", map[i][j]);
		}
}
```

# 1098 : [기초-2차원배열] 설탕과자 뽑기

문제설명

부모님과 함께 유원지에 놀러간 영일이는
설탕과자(설탕을 녹여 물고기 등의 모양을 만든 것) 뽑기를 보게 되었다.

길이가 다른 몇 개의 막대를 바둑판과 같은 격자판에 놓는데,

막대에 있는 설탕과자 이름 아래에 있는 번호를 뽑으면 설탕과자를 가져가는 게임이었다.
(잉어, 붕어, 용 등 여러 가지가 적혀있다.)
격자판의 세로(h), 가로(w), 막대의 개수(n), 각 막대의 길이(l),
막대를 놓는 방향(d:가로는 0, 세로는 1)과
막대를 놓는 막대의 가장 왼쪽 또는 위쪽의 위치(x, y)가 주어질 때,

격자판을 채운 막대의 모양을 출력하는 프로그램을 만들어보자.

정답

```
#include <stdio.h>

int h, w, n;
int l, d, x, y;
int i, j;
int map[2000][2000];

main()
{
	scanf("%d%d%d", &h, &w, &n);
	for(i=0; i < n; i++)
	{
		scanf("%d%d%d%d", &l, &d, &x, &y);
		if(d == 0)
		{
			for(j=y; j<y+l; j++)
				map[x][j] = 1;
		}
		else
		{
			for(j=x; j <x+l; j++)
				map[j][y] = 1;
		}		
	}
	
	for(i=1; i <= h; i++, puts(""))
		for(j=1; j <= w; j++)
		{
			printf("%d ", map[i][j]);
		}
}
```

# 1099 : [기초-2차원배열] 성실한 개미

문제설명

영일이는 생명과학에 관심이 생겨 왕개미를 연구하고 있었다.

왕개미를 유심히 살펴보던 중 특별히 성실해 보이는 개미가 있었는데,
그 개미는 개미굴에서 나와 먹이까지 가장 빠른 길로 이동하는 것이었다.

개미는 오른쪽으로 움직이다가 벽을 만나면 아래쪽으로 움직여 가장 빠른 길로 움직였다.
(오른쪽에 길이 나타나면 다시 오른쪽으로 움직인다.)

이에 호기심이 생긴 영일이는 그 개미를 미로 상자에 넣고 살펴보기 시작하였다.

미로 상자에 넣은 개미는 먹이를 찾았거나, 더 이상 움직일 수 없을 때까지
오른쪽 또는 아래쪽으로만 움직였다.

미로 상자의 구조가 0(갈 수 있는 곳), 1(벽 또는 장애물)로 주어지고,
먹이가 2로 주어질 때, 성실한 개미의 이동 경로를 예상해보자.

단, 맨 아래의 가장 오른쪽에 도착한 경우, 더 이상 움직일 수 없는 경우, 먹이를 찾은 경우에는
더이상 이동하지 않고 그 곳에 머무른다고 가정한다.


미로 상자의 테두리는 모두 벽으로 되어 있으며,
개미집은 반드시 (2, 2)에 존재하기 때문에 개미는 (2, 2)에서 출발한다.

정답

```
#include <stdio.h>
int map[12][12];

void back(int r, int c)
{
	if(map[r][c] == 2)
	{
			map[r][c] = 9;
			return ;
	}
	map[r][c] = 9;

	if(map[r][c+1] != 1)
		back(r, c+1);
	else if(map[r+1][c] != 1)
		back(r+1, c);
}

int main()
{
	int i, j;
	for(i = 1; i <= 10; i++)
		for(j = 1; j <= 10; j++)
			scanf("%d", &map[i][j]);
	back(2, 2);

	for(i = 1; i <= 10; i++,puts(""))
		for(j = 1; j <= 10; j++)
			printf("%d ", map[i][j]);
}
```